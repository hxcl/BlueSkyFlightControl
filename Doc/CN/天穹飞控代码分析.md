# 天穹飞控代码分析

## 任务流程

天穹飞控使用 FreeRTOS 进行管理，下面列出了所有的任务并对其执行频率、功能等进行了说明。

| 任务名称             | 任务优先级 | 执行频率/Hz | 任务说明                           | 补充                   |
| -------------------- | ---------- | ----------- | ---------------------------------- | ---------------------- |
| vImuSensorReadTask   | 13         | 1000        | 读取陀螺仪与加速度计的原始数据     | 通过队列发送结果       |
| vImuDataPreTreatTask | 12         | 1000        | 对陀螺仪和加速度计的原始数据预处理 | 通过队列接收和发送结果 |
| vNavigationTask      | 11         | 1000        | 卡尔曼滤波预测姿态                 |                        |
|                      |            |             | 飞行速度估计与位置估计             |                        |
| vFlightControlTask   | 10         | 100         | 遥控器控制与失控检测               |                        |
|                      |            | 200         | 位置外环                           |                        |
|                      |            | 50          | 用户控制                           |                        |
|                      |            | 50          | 任务控制                           |                        |
|                      |            | 50          | 位置内环                           |                        |
|                      |            | 50          | 姿态外环                           |                        |
|                      |            | 50          | 高度外环                           |                        |
|                      |            | 50          | 姿态与高度内环                     |                        |
|                      |            | 1000        | 电机更新                           |                        |
| vSensorUpdateTask    | 8          | 100         | 地磁传感器读取                     |                        |
|                      |            | 50          | 气压传感器读取                     |                        |
|                      |            | 20          | 飞控参数保存                       |                        |
|                      |            | 200         | 电池状态与 RGB 灯                  |                        |
| vOtherSensorTask     | 7          | 100         | 地磁数据预处理                     |                        |
|                      |            | 25          | 气压数据预处理                     |                        |
|                      |            | 10          | GPS 数据处理                       |                        |
| vMessageTask         | 6          | 100         | bsplink/mavlink 数据发送           |                        |
| vFlightStatusTask    | 5          | 100         | 飞行状态刷新等                     | 要详细了解作用         |
| vLogTask             | 3          | 100         | 向 TF 卡写入飞行日志               |                        |

`main()` 函数调用了 `HAL_Init()` 和 `SystemClock_Config()` 以后即创建起始任务，然后初始化 FreeRTOS 相关配置并开启调度，将控制权交予调度器。

### vStartTask

起始任务包含初始化、任务创建和状态更新三部分。

`Board_Init()`其实就是 `MX_XXX_Init()`的汇总，某些外设可能还加入了额外的内容。在这一步，RGB 灯会全数熄灭。`ParamInit()`从 Flash 中读取参数并校验，如果校验失败，会将所有参数置零。需要注意的是，这里的置零是指保存在内存中的参数置零，而不是将零值写入 Flash 里面，后者的操作是异步的。`FaultDetectInit()` 将错误和警告标志位清零，然后置位“系统初始化”警告标志位。`MessageQueueCreate()`顾名思义，为任务间通信提供消息队列，至于具体的可以看上面部分或者代码。

任务创建部分比较简单，依次调用任务创建函数即可。

完成上述工作以后，空闲任务进入到循环中。起始任务的优先级为 0 与空闲任务相同，因此会隔 5s 更新一次 CPU 使用率和栈使用情况，与空闲任务交替进行。

### vImuSensorReadTask

如前文所述，该任务拥有最高优先级，运行频率 1kHz。它的主要任务是读取 IMU 的加速度、角速度原始数据和温度数据并填充到相应的消息队列当中，传递给下一个任务。该任务还同时承担了检测 IMU 状态的任务：在读取数据之前会首先挂起调度器检测 IMU 状态，若 IMU 未能正确相应，将置位相应的警告标识。

### vImuDataPreTreatTask



## 导航

导航相关代码位于 *Project/SRC/NAVIGATION/* 目录下，包含辅助姿态估计 arhsAux、姿态估计 arhs 和速度估计、位置估计 navigation 三组代码文件。

### 姿态估计

姿态估计分为姿态估计和辅助姿态估计两部分。

辅助姿态估计使用三阶 Kalman 滤波算法进行姿态估计，但不包括 Yaw 角的估计。在进行姿态估计之前，初始对准函数会采样加速度测量值并求平均，意味着**静止状态的加速度向量作为 Kalman 滤波状态的初始状态**，加速度和磁力计测量值则共同计算得到当前欧拉角与四元数。初始计算完成以后不再进行初始对准。辅助姿态估计首先对向心加速度进行补偿，然后将六轴数据使用 Kalmann 滤波算法计算得到欧拉角。具体来说，首先加速度测量值减去向心加速度（在姿态估计中给出）的偏差，角速度测量值通过积分得到角速度变化量并转化为 DCM 作为 Kalman 滤波的状态转移矩阵，经过 Kalman 滤波算法得到**当前的状态值，以加速度向量的形式**。

辅助姿态估计的显著问题是它直接使用加速度值作为 Kalman 滤波算法的观测量输入，忽略了运动加速度的影响。这一问题将在正式的姿态估计部分解决，也因为如此，辅助姿态估计的最后一个任务是根据姿态预测结果，给出飞行器的运动加速度。

姿态估计同样使用 Kalman 滤波算法进行。在进行之前会有初始对准的过程，加速度测量值和磁力计测量值分别作为 Roll & Pitch 估计的初始状态和 Yaw 估计的初始状态。俯仰/偏航估计过程与辅助姿态估计相似，区别是加速度测量值会经过运动加速度补偿、向心加速度补偿和零偏补偿，其中**运动加速度的数据来自辅助姿态估计**。偏航估计过程较为简单，同样是角速度积分转化为 DCM 作为状态转移矩阵预估计，再用磁强观测量完成估计。

尽管姿态估计过程看起来并不复杂，但仍有许多值得探究的地方。例如俯仰/偏航估计观测误差协方差矩阵的自适应算法、初始化过程的处理、运动加速度的补偿参数等。

### 速度估计

速度估计使用六阶 Kalman 滤波算法进行估计，以三轴速度和三轴加速度偏差作为状态量，GPS、气压计的速度值作为观测量，体系加速度作为状态转移量。计算均在机体系下进行。

```c
//更新输入量
input[0] = accel.x;
input[1] = accel.y;
input[2] = accel.z;

//更新输入转移矩阵
kalman->b[0][0] = kalman->b[1][1] = kalman->b[2][2] = deltaT * GRAVITY_ACCEL * 100;

//更新状态转移矩阵
kalman->f[0][3] = kalman->f[1][4] = kalman->f[2][5] = deltaT;

//1:状态预估计 Xk = Fk*Xk-1 + Bk*Uk
Matrix6MulVector6(kalman->f, kalman->state, v1);
Matrix6MulVector6(kalman->b, input, v2);
Vector6f_Add(v1, v2, kalman->state);
```

### 位置估计

位置估计较为简单，使用三阶 Kalman 滤波算法，以速度的积分值作为输入量，位置测量值作为观测量。

## 传感器程序架构设计

在实际应用中，飞控会使用到不同种类、不同型号的传感器，因此一个设计良好的传感器程序架构能有效提高程序的可读性和可维护性，对高层次的应用开发也大有裨益。

### 程序组成分析

传感器的程序按执行顺序可以分为以下几步：

1. 传感器初始化
2. 传感器原始数据获取与解析。
3. 传感器数据处理。
4. 传感器数据被其他程序读取。

初始化很容易理解，包括采样率设置、校准参数获取等等内容。

原始数据获取与解析是指主控芯片通过 SPI/I2C/UART 等通讯接口获取传感器输出的原始数据，并转化为通用的格式。从通信方式分类，可分为主动式和被动式两种。六轴/九轴 IMU、气压计、磁力计均属主动式通信，由主控芯片发起 SPI/I2C 传输，传感器再进行应答，阻塞传输。对于这种传感器，只需要在定时任务中按一定频率发起读取数据即可，对应有 *vImuSensorReadTask* 和 *vSensorUpdateTask* 两个任务。被动式传输主要有 GPS、光流和 ToF 高度传感器，它们均采用 UART 接口，以一定的时间间隔发送数据，主控芯片则要被动接收。对于这类传感器，应当使用中断或者 DMA 的方式接收数据并缓存。显然，被动式传输的传感器无需专门使用任务来获取数据。

传感器数据处理涉及的内容较多，例如陀螺仪需要纠正零偏误差、气压计数据需要滤波处理等等。可想而知，这一部分应当在获取到原始数据以后立即执行。因此我们对应有 *vImuDataPreTreatTask* 和 *vOtherSensorTask* 两个任务。需要注意的是，本段提及的“处理”仅限于“给出正确的测量值”。举个例子，姿态估计算法中需要对加速度计的测量结果去除向心加速度分量、分解出重力加速度分量和运动加速度分量，这些均不属于加速度测量值的范畴，因而不应纳入本部分。

传感器数据被其他程序获取是传感器数据的终点。为此，程序需要提供合理的接口。

### 程序架构分析

显然，传感器的初始化和原始数据获取程序都是和具体的传感器型号密切相关的，因此飞控程序首先要包含各种型号的传感器驱动，这部分代码在 *Project/SRC/MODULE/* 目录下。以六轴 IMU 传感器 icm-20689 为例，驱动文件提供了初始化、读取加速度向量、角速度向量和温度的函数。

```c
bool ICM20689_Detect(void);
void ICM20689_Init(void);

void ICM20689_ReadAcc(Vector3f_t* acc);
void ICM20689_ReadGyro(Vector3f_t* gyro);
void ICM20689_ReadTemp(float* temp);
```

不同的飞控板可能使用了不同的 IMU 传感器，为了灵活适应这一情况，本目录下还有 *module.c* 文件为传感器类型提供了抽象，根据飞控配置文件定义的传感器型号，调用不同的驱动。这也是原始数据获取任务中实际调用的函数。以角速度传感器的初始化为例。

```c
void GyroSensorInit(void) {
    uint8_t detectFlag = 0;

    if(GYRO_TYPE == ICM20689){
        if (ICM20689_Detect()) {
            ICM20689_Init();
            detectFlag = 1;
        }
    }
    else if(GYRO_TYPE == ICM20948){
        if (ICM20948_Detect()) {
            ICM20948_Init();
            detectFlag = 1;
        }
    }
    //未检测到陀螺仪
    if (!detectFlag) {
        FaultDetectSetError(GYRO_UNDETECTED);
    }
}
```

与原始数据读取与解析不同，传感器数据处理一般与特定的传感器型号没有太大关系，而与传感器实现原理息息相关。例如加速度计的物理特性决定其测量结果中有高频分量、光流传感器的测量原理决定得到的原始位移值需要和机体旋转角度解耦。因此这一步应当根据传感器类别编写程序，此部分代码在 *Project/SRC/SENSOR/* 目录下面。以加速度计为例，给出了加速度计的功能抽象和数据获取函数。

```c
void AccPreTreatInit(void);
void AccDataPreTreat(Vector3f_t accRaw, Vector3f_t* accData);
void AccCalibration(Vector3f_t accRaw);
void AccScaleCalibrate(Vector3f_t* acc);
void ImuLevelCalibration(void);

Vector3f_t GetAccOffsetCaliData(void);
Vector3f_t GetAccScaleCaliData(void);
Vector3f_t GetLevelCalibraData(void);

void AccCalibrateEnable(void);
void LevelCalibrateEnable(void);

float GetAccMag(void);
Vector3f_t AccGetData(void);
Vector3f_t AccLpfGetData(void);
```

### 传感器失效处理



### 光流和 ToF 激光测高传感器架构

loveuav 在开发天穹飞控时并没有加入光流和 ToF 测高传感器的支持。

按照原有代码结构，传感器的初始化函数应当放在 *sensorUpdateTask* 任务当中。但该任务属于定时执行任务，我认为初始化在定时任务中执行并不恰当，因此将其转移到到了 `boardInit()`当中，即初始化任务。

